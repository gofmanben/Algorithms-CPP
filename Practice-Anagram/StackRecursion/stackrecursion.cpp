// Filename: stackrecursion.cpp
//
// The file basically contains a number of string functions that are "fundamentally" (or naturally) recursive,
// but are implemented with a stack.
// 
// The functions are: generating all stretches, generating all anagrams, generating the language from a string.
// For details about these functions, refer to the file stackrecursion_qns.pdf.
// 
// Each of these functions returns a list of strings. The main code only calls one of these functions,
// and the remaining calls are commented out. You can uncomment the function you want.
// Finally, the code sorts the list by lexicographic order, and prints the strings to the output file (each in a separate line).
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     The first line of <INPUT FILE> is read, as a string. The second line is optionally read as an int, if the desired
// function (language, stretch) requires an int argument. Again, all of this is hardcoded, so you need to comment/uncomment
// the desired lines to run different functions. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>
using namespace std;


// This class keeps pairs of string. This may be useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        string fixed_str;
};


 // This function generates all anagrams/permutations of the input in_str, and outputs them as a list. This function does not use recursion.
// Input: string in_str
// Output: list of all anagrams of in_str

List allAnagrams(string input_str)
{
    /*
    1. Create an empty result list that will store all generated anagrams and return it at the end of the function.
    2. Determine the length of the input sequence. If the length is 1, insert the input argument into result and return it as the base case.
    3. Iterate through each element of the input sequence by index.
    4. Select the element at the current index to be used as the prefix (character or integer, depending on the input type).
    5. Construct a new sequence ("remaining") by removing the element at the current index.
    6. Recursively call allAnagrams with the remaining sequence to generate all sub-anagrams.
    7. Traverse through the list of sub-anagrams returned from the recursive call. 
    8. For each sub-anagram, prepend the selected element and insert the new sequence into the result list.
    */

    List result;
    return result;
    












    /*int size = input_str.length();

    List result;
    if (size == 1) {
        result.insert(input_str);
        return result;
    }

    for (int i = 0; i < size; i++) {
        char c = input_str[i];
        string remaining = input_str.substr(0, i) +
                           input_str.substr(i + 1);
        // Or
        //for (int j = 0; j < size; j++) {
        //   if (i != j) remaining += input_str[j]; 
        //}
        // cout << "c=" << c << ",remaining=" << remaining << endl;
        
        List perms = allAnagrams(remaining);

        Node* cur = perms.head;
        while (cur) {
        // cout << c + cur->word << endl << endl;
        result.insert(c + cur->word);
        cur = cur->next;
        }
        
        perms.deleteList(); // free all the memory of this list
    }
    return result;*/
/*

    List list;                 // list to store all anagrams
    stack<Pair> stk;           // explicit stack to simulate recursion

    // initial state: nothing fixed, entire string remaining
    Pair start;
    start.in_str = input_str;
    start.fixed_str = "";
    stk.push(start);

    while (!stk.empty())
    {
        Pair current = stk.top();
        stk.pop();

        // base case: no characters left to fix
        if (current.in_str.empty())
        {
            list.insert(current.fixed_str);
            continue;
        }

        // simulate recursive branching
        for (int i = 0; i < (int)current.in_str.length(); i++)
        {
            Pair next;
            next.fixed_str = current.fixed_str + current.in_str[i];

            // remove character i from in_str
            next.in_str =
                current.in_str.substr(0, i) +
                current.in_str.substr(i + 1);

            stk.push(next);
        }
    }

    return list;
    */
}



int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./stackrecursion <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str; // to store the input string from the file

    getline(input, in_str); // get the single string from the input file

    List myList = allAnagrams(in_str); // generate all anagrams and store in the linked list

    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    //output.flush();
    myList.deleteList(); // free all the memory of this list

    input.close(); // close the I/O files
    output.close();
}
