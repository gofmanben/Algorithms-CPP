// Filename: stackrecursion.cpp
//
// The file basically contains a number of string functions that are "fundamentally" (or naturally) recursive,
// but are implemented with a stack.
// 
// The functions are: generating all stretches, generating all anagrams, generating the language from a string.
// For details about these functions, refer to the file stackrecursion_qns.pdf.
// 
// Each of these functions returns a list of strings. The main code only calls one of these functions,
// and the remaining calls are commented out. You can uncomment the function you want.
// Finally, the code sorts the list by lexicographic order, and prints the strings to the output file (each in a separate line).
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     The first line of <INPUT FILE> is read, as a string. The second line is optionally read as an int, if the desired
// function (language, stretch) requires an int argument. Again, all of this is hardcoded, so you need to comment/uncomment
// the desired lines to run different functions. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020, Oct 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>
using namespace std;


// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        string fixed_str;
};       

// This function generates all bubblines of the input in_str, and outputs them as a list. This function does not use recursion.
// Input: string in_str
// Output: list of all bubblings of in_str

List allBubblings(string in_str)
{
    List result;
    stack<Pair> stk;

    Pair p;
    p.in_str = in_str;
    p.fixed_str = "";
    stk.push(p);
    result.insert(in_str);

    while (!stk.empty())
    {
        Pair curr = stk.top();
        stk.pop();

        string pIn_str = curr.in_str;
        string pFixed_str = curr.fixed_str;

        int strSize = pIn_str.size();
        int fixedSize = pFixed_str.size();

        for (int i = 1; i < strSize; i++)
        {
            // only swap strictly after the fixed prefix
            if (i > fixedSize)
            {
                string next = pIn_str;
                swap(next[i], next[i - 1]);

                Pair nextPair;
                nextPair.in_str = next;

                // extend the fixed prefix through index i-1 (prefix length becomes i)
                nextPair.fixed_str = next.substr(0, i);

                if (result.find(next) == NULL)
                {
                    result.insert(next);
                    stk.push(nextPair);
                }
            }
        }
    }

    return result;
}


int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str, len_str; // to store the input string from the file

    getline(input, in_str); // get the single string from the input file

    List myList = allBubblings(in_str); // getting all bubblings into the linked list

    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    
    myList.deleteList(); // free all the memory of this list

    input.close(); // close the I/O files
    output.close();
}
