// Filename: stackrecursion.cpp
//
// The file basically contains a number of string functions that are "fundamentally" (or naturally) recursive,
// but are implemented with a stack.
// 
// The functions are: generating all stretches, generating all anagrams, generating the language from a string.
// For details about these functions, refer to the file stackrecursion_qns.pdf.
// 
// Each of these functions returns a list of strings. The main code only calls one of these functions,
// and the remaining calls are commented out. You can uncomment the function you want.
// Finally, the code sorts the list by lexicographic order, and prints the strings to the output file (each in a separate line).
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     The first line of <INPUT FILE> is read, as a string. The second line is optionally read as an int, if the desired
// function (language, stretch) requires an int argument. Again, all of this is hardcoded, so you need to comment/uncomment
// the desired lines to run different functions. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>
using namespace std;


// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        string fixed_str;
};

// This function generates all strings obtained by duplicating the characters in the input string at most k times
// Input: string input_str, int k
// Output: list of all strings of obtained by duplicating characters in input_str at most k
// 
List stretch(string input_str, int k)
{
    /*
    1. Create an empty result list that will store all generated stretched strings and return it at the end of the function.
    2. If the input sequence is empty or k < 1, insert an empty sequence into result and return it as the base case.
    3. Select the first element of the input sequence to be processed.
    4. Construct a new sequence ("remaining") by removing the selected element from the input sequence.
    5. Recursively call stretch using the remaining sequence to generate all possible sub-results.
    6. Traverse through the list of sub-results returned from the recursive call.
    7. For each sub-result, prepend the selected element repeated from 1 up to k times
    8. Insert each newly constructed sequence into result.
    */
    /*List result;

    if (input_str.empty() || k < 1) {
        result.insert("");
        return result;
    }

    char c = input_str[0];
    string remaining = input_str.substr(1);

    List sub = stretch(remaining, k);

    Node* cur = sub.head;
    while (cur)
    {
        for (int i = 1; i <= k; i++)
            result.insert(string(i, c) + cur->word); // string constructor repeat character c exactly i times, then append the rest of the string.
        cur = cur->next;
    }

    sub.deleteList(); // free all the memory of this list
    return result;*/
    
    List out;

    if (k < 0)
        return out;

    stack<Pair> st;
    st.push(Pair{input_str, ""});

    while (!st.empty())
    {
        Pair cur = st.top();
        st.pop();

        if (cur.in_str.empty())
        {
            out.insert(cur.fixed_str);
            continue;
        }

        char c = cur.in_str[0];
        string rest = cur.in_str.substr(1);

        for (int i = 1; i <= k; i++)
        {
            Pair nxt;
            nxt.in_str = rest;
            nxt.fixed_str = cur.fixed_str + string(i, c);
            st.push(nxt);
        }
    }

    return out;
}



int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str, len_str; // to store the input string from the file

    getline(input, in_str); // get the single string from the input file
    getline(input, len_str); // get the single string from the input file
    
    List myList = stretch(in_str,stoi(len_str)); // calling with the right arguments, and getting the output in a list

    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    
    myList.deleteList(); // free all the memory of this list

    input.close(); // close the I/O files
    output.close();
}
